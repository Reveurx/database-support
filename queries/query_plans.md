## План выполнения (EXPLAIN ANALYZE) Q1:

### Проведённые улучшения производительности:

1. **Созданы целевые индексы на ключевые поля:**
   - `Posts(PostTypeId)` — для ускорения фильтрации по типу поста.
   - `Posts(AcceptedAnswerId)` — для оптимизации `JOIN` по `AcceptedAnswerId`.
   - `Posts(OwnerUserId)` — для ускорения соединения ответов с авторами.
   - `Users(Id)` — для соединения с авторами и доступа к их репутации.
   - Также можно индексировать — `Posts(Tags)` либо `Posts(LOWER(Tags))` с использованием GIN-индекса и расширения `pg_trgm`, чтобы ускорить поиск `LIKE '%|postgresql|%'`.

2. **Улучшено использование CTE (Common Table Expressions):**
   - Временные таблицы `postgresql_questions` и `valid_answers` помогают избежать повторной фильтрации и переиспользуются в последующих выражениях.

3. **Снижено количество обрабатываемых строк:**
   - Применена фильтрация по `AcceptedAnswerId IS NOT NULL` и `PostTypeId`, что позволило значительно сузить выборку на ранних этапах выполнения запроса.
   - Отсечены малозначимые пары тегов с помощью `HAVING COUNT(*) >= 5`, что уменьшило нагрузку на агрегирующий этап.

4. **Добавлены агрегаты с дискретизацией (`PERCENTILE_CONT`) и корреляцией (`COVAR_POP`, `STDDEV_POP`) только на релевантных выборках**, что минимизировало накладные расходы при работе с крупными таблицами.

5. **Оптимизация порядка фильтрации:**
   - Фильтрация по тегам и типу поста выполняется в рамках первых CTE, что позволило значительно уменьшить объём обрабатываемых данных ещё до основного `JOIN`.
Вот как грамотно оформить анализ плана выполнения в README.md:

## Анализ производительности запроса

### Текущие показатели
- **Общее время выполнения:** 547 мс
- **Самые затратные операции:**
  - Фильтрация вопросов с тегом postgresql: 106 мс
  - Обработка пар тегов (вложенные циклы): 472 мс
  - Сортировка промежуточных результатов: использовано 2827kB памяти

### Ключевые узкие места
1. **Полное сканирование таблицы `posts`**:
   - Обработано 245,757 строк (79,019 на worker)
   - После фильтрации осталось 24,721 строк (30% эффективность)

2. **Проблемные соединения**:
   ```
   Nested Loop с Join Filter
   - Итераций: 1,236,050 (24,721 × 50)
   - Отфильтровано: 1,202,652 строк (97% несоответствий)
   ```

3. **Ресурсоемкие операции**:
   - Сортировка 31,499 строк заняла 2827kB памяти
   - Множественные обращения к индексам (33,398 сканирований `posts_pkey`)

### Оптимизации

#### 1. Рекомендуемые индексы
```sql
CREATE INDEX idx_posts_postgresql_questions ON posts(posttypeid, tags)
WHERE posttypeid = 1 AND tags LIKE '%|postgresql|%' AND acceptedanswerid IS NOT NULL;

CREATE INDEX idx_posts_accepted_answers ON posts(id, posttypeid, owneruserid, creationdate)
WHERE posttypeid = 2;
```

#### 2. Настройки PostgreSQL
```sql
-- Для данного запроса
SET LOCAL work_mem = '32MB';
SET LOCAL enable_hashjoin = ON;
```

#### 3. Ожидаемые улучшения
| Метрика               | До оптимизации | После (ожидается) |
|-----------------------|---------------|-------------------|
| Время выполнения      | 547 мс        | 150-250 мс        |
| Память для сортировки | 2827kB        | ~500kB            |
| Число итераций       | 1.2M+         | ~50k              |

### Временные показатели операций
```text
Фильтрация вопросов         106 мс │██████████▌
Обработка пар тегов         472 мс │██████████████████████▌
Сортировка результатов       15 мс │█▌
```

### Выводы
Основная проблема - неэффективные соединения и отсутствие специализированных индексов. После внедрения рекомендаций ожидается ускорение запроса в 2-3 раза.

## Анализ производительности запроса Q2:

### Общие показатели
- **Время выполнения:** 151.5 мс
- **Обработано строк:** 
  - Всего: 26,256 (8,754 на worker × 3)
  - После фильтрации: 8,754 (33% эффективность)
- **Использование памяти:** до 48kB для сортировки

### Ключевые этапы выполнения

1. **Фильтрация вопросов (Parallel Seq Scan)**
   - Время: 72.5 мс (48% общего времени)
   - Обработано: 81,919 строк на worker
   - Эффективность: 2,918 строк осталось после фильтра (3.6%)

2. **Соединение с ответами (Nested Loop)**
   - Итераций: 8,754
   - Время: 7.6 мс (5% времени)
   - Использован индекс `posts_pkey`

3. **Соединение с авторами (Nested Loop)**
   - Итераций: 8,754
   - Время: 7.6 мс (5% времени)
   - Использован индекс `users_pkey`

4. **Сортировка результатов (Top-N heapsort)**
   - Время: 0.002 мс
   - Память: 48kB (мастер), 41-44kB (workers)

### Проблемные места

1. **Неэффективная фильтрация вопросов**:
   - Полное сканирование таблицы `posts` (245,757 строк)
   - Высокий процент отфильтрованных строк (96.4%)

2. **Избыточные соединения**:
   - Двойной доступ к таблице `posts` (вопросы + ответы)
   - 8,754 избыточных обращений к таблице `users`

### Рекомендации по оптимизации

#### 1. Создание специализированных индексов
```sql
-- Для быстрого поиска вопросов с тегом postgresql
CREATE INDEX idx_posts_postgresql_questions ON posts(posttypeid, tags)
WHERE posttypeid = 1 AND tags LIKE '%|postgresql|%' AND acceptedanswerid IS NOT NULL;

-- Для быстрого доступа к ответам
CREATE INDEX idx_posts_accepted_answers ON posts(id, posttypeid, owneruserid)
WHERE posttypeid = 2;
```

#### 2. Настройки PostgreSQL
```sql
-- Для данного запроса
SET LOCAL work_mem = '16MB';
SET LOCAL random_page_cost = 1.1;  -- Для SSD
SET LOCAL enable_seqscan = OFF;    -- Принудительно использовать индексы
```

### Ожидаемые улучшения

| Метрика               | До оптимизации | После (ожидается) |
|-----------------------|---------------|-------------------|
| Время выполнения      | 151 мс        | 30-50 мс          |
| Обработанные строки   | 245k          | ~5k               |
| Использование памяти  | 48kB          | ~16kB             |

### Временной профиль (ожидаемый после оптимизации)
```text
Фильтрация вопросов         10 мс │████▌
Соединение с ответами       5 мс  │██▌
Соединение с авторами       5 мс  │██▌
Сортировка результатов     0.1 мс │▌
```

### Выводы
После создания специализированных индексов и оптимизации запроса ожидается ускорение в 3-5 раз. Основной выигрыш будет достигнут за счет:
1. Устранения полного сканирования `posts`
2. Снижения количества соединений
3. Более эффективного использования памяти
